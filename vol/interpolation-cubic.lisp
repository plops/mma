(in-package :vol)

;; I read Brian Amberg ba_interp3.cpp

(declaim (inline access access-unchecked indices-cubic))

(defun access (vol k j i)
  (declare ((simple-array single-float 3) vol)
	   (fixnum k j i)
	   (values fixnum &optional))
  (destructuring-bind (z y x) (array-dimensions vol)
    (macrolet ((clamp (x n)
		 `(if (< ,x 0)
		      0
		      (if (<= ,n ,x) 
			  (- ,n 1)
			  ,x))))
      (let ((k (clamp k z))
	    (j (clamp j y))
	    (i (clamp i x)))
	(array-row-major-index vol k j i)))))

(defun access-unchecked (vol k j i)
  (declare ((simple-array single-float 3) vol)
	   (fixnum k j i)
	   (values fixnum &optional))
  (array-row-major-index vol k j i))

(defun indices-cubic (vol k j i &key 
		      (indices (make-array (list 4 4 4) :element-type 'fixnum)))
  (declare ((simple-array single-float 3) vol)
	   ((simple-array fixnum (4 4 4)) indices)
	   (fixnum k j i)
	   (values (simple-array fixnum (4 4 4)) &optional))
  (destructuring-bind (z y x) (array-dimensions vol)
    (if (or (<= k 2) (<= j 2) (<= i 2) 
	    (<= (- z 3) k) (<= (- y 3) j) (<= (- x 3) i))
	(do-region ((c b a) (4 4 4))
	  (setf (aref indices c b a)
		(access vol (+ k c -1) (+ j b -1) (+ i a -1))))
	(do-region ((c b a) (4 4 4))
	  (setf (aref indices c b a)
		(access-unchecked vol (+ k c -1) (+ j b -1) (+ i a -1)))))
    indices))

(defmacro def-vars (x &body body)
  "Calculate some intermediate local values that are needed for the
interpolation and have the same structure in each dimension."
  (let ((dx (intern (format nil "D~a" x)))
	(dxx (intern (format nil "D~a~a" x x)))
	(dxxx (intern (format nil "D~a~a~a" x x x)))
	(wx0 (intern (format nil "W~a0" x)))
	(wx1 (intern (format nil "W~a1" x)))
	(wx2 (intern (format nil "W~a2" x)))
	(wx3 (intern (format nil "W~a3" x))))
    `(let* ((,dxx (* ,dx ,dx))
	    (,dxxx (* ,dxx ,dx))
	    (,wx0 (* .5 (+ (- ,dx) (* 2 ,dxx) (- ,dxxx))))
	    (,wx1 (* .5 (+ 2 (* -5 ,dxx) (* 3 ,dxxx))))
	    (,wx2 (* .5 (+ ,dx (* 4 ,dxx) (* -3 ,dxxx))))
	    (,wx3 (* .5 (+ (- ,dxx) ,dxxx))))
       ,@body)))
#+nil
(def-vars z)

(defun interpolate-cubic (vol z y x)
  (declare ((simple-array single-float 3) vol)
	   (single-float z y x)
	   (values single-float &optional))
  (let ((p (sb-ext:array-storage-vector vol)))
   (multiple-value-bind (ix dx) (floor x)
     (multiple-value-bind (iy dy) (floor y)
       (multiple-value-bind (iz dz) (floor z)
	 (let ((f (indices-cubic vol iz iy ix)))
	   (def-vars z
	     (def-vars y
	       (def-vars x
		 (with-arrays (p f)
		   (labels ((dir-y (z y)
			      (+ (* wx0 (p (f z y 0))) (* wx1 (p (f z y 1)))
				 (* wx2 (p (f z y 2))) (* wx3 (p (f z y 3)))))
			    (dir-z (z)
			      (+ (* wy0 (dir-y z 0))
				 (* wy1 (dir-y z 1))
				 (* wy2 (dir-y z 2))
				 (* wy3 (dir-y z 3)))))
		     (declare (inline dir-y dir-z))
		     (+ (* wz0 (dir-z 0))
			(* wz1 (dir-z 1))
			(* wz2 (dir-z 2))
			(* wz3 (dir-z 3))))))))))))))

#+nil
(let ((a (make-array (list 4 4 4) :element-type 'single-float
		     :initial-contents '(((0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0))
					 ((0s0 1s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0))
					 ((0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0))
					 ((0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0)
					  (0s0 0s0 0s0 0s0))))))
 (interpolate-cubic a 1.1s0 1.2s0 1.3s0))

#+nil
(time
 (let ((a (make-array (list 64 64 64) :element-type 'single-float))
       (b (make-array (list 500 500) :element-type 'single-float)))
   (destructuring-bind (z y x) (array-dimensions a)
     (do-region ((k j i) (z y x))
       (let* ((xx (/ (- i (floor x 2)) x))
	      (yy (/ (- j (floor y 2)) y))
	      (zz (/ (- k (floor z 2)) z))
	      (r (sqrt (+ (* xx xx) (* yy yy) (* zz zz)))))
	 (setf (aref a k j i) (+ 13.1s0 (+ (sin (* 120s0 xx)) (cos (* 70s0 r)))))))
     (destructuring-bind (yy xx) (array-dimensions b)
       (let ((sum 0d0))
	(do-region ((j i) (yy xx))
	  (let* ((cz (* 1s0 z (/ j yy)))
		 (cy 32s0)
		 (cx (* 1s0 x (/ i xx)))
		 (xx (/ (- cx (floor x 2)) x))
		 (zz (/ (- cz (floor z 2)) z))
		 (r (sqrt (+ (* xx xx) (* zz zz)))))
	    (setf (aref b j i)
		  (let ((q (- #+nil(interpolate-cubic a cz cy cx)
			      (interpolate a cx cy cz)
			      (+ 13.1s0 (+ (sin (* 120s0 xx)) (cos (* 70s0 r))))
			      )))
		   (* q q)
		   ))
	    (incf sum (aref b j i))))
	(write-pgm "/dev/shm/o.pgm" (normalize-2-sf/ub8 b))
	(defparameter *look* sum)
	sum)))))
#+nil
(/ *look* (* 500 500))
;; .02 cubic
;; 2.2 linear